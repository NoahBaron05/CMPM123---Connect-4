# Connect-4 With Negamax AI - Noah Baron - CMPM 123

This application runs many different games, with the central focus being Connect-4. Players can choose between a 2-player game, and playing an AI, where either the AI plays first or second.

For my implementation, I began by creating the core of the game by utilizing the BitHolder and Grid classes to set-up the board. After board creation, I implemented simple logic to place pieces by using the given grid and bitholder functions, and specialized them so players could only do Connect-4 specific moves, by only placing bits at the lowest possible point in a column. Then I created a simple win and draw function, which involved looping over the board and checking for wins in every possible direction. The draw state was determined by checking to see if the board is full, and then doing a sanity check by calling check for winner again. This finalized the base implementation for Connect-4, but much of the work was spend on the negamax AI.

I began devlopment of the AI simply by starting with the negamax function. Negamax looks similar in many implementations, but here I specifically utilized alpha-beta pruning to optimize the AI and allow it to run better, and make better choices. Then I created a make move function, to make a possible move and returning a state string of that move. The negamax utilizes this function to look at every possible move that can be done within the depth limit. Finally, and where the bulk of the work was, came the evaluate function. For this function, I chose to implement readability over AI optimization. So I began by creating a simple evaluate function where the code looks over every possible situation, and determines a score based on if there is a winner, or more pieces in a row. Later I tweaked this evaluate function to do two main things. First, I added column weights so the AI would be influenced to play more in the center (better move). This influenced the AI significantly, and made it make better plays. Second, I changed the evaluate function so that it used the window method instead. This meant that the evaluate would look each direction of win, find the possible win spots, and check for wins in that, rather than every single bit. This optimized the AI significantly, and allowed it to have a deeper depth search. Finally, I worked on bug fixing, including the main bug, where the AI would not go for the immediate win, and would rather stack up multiple game winning moves later in the game. This was implemented by checking for a winning move before running negamax, and if it returned true, the AI would place there.

This was developed on Windows 10, based on Graeme Devine's source code for UCSC's CMPM 123 class.